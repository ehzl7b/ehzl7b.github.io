---
layout: page
title: 동적 계획법(Dynamic Programming)과 메모이제이션(Memoization)
updated: 수학의 점화식 풀이와 유사한 동적 계획법 알고리즘과, 과도한 재귀호출을 줄일 수 있는 메모이제이션 기법 소개
updated: 2024-05-23
---

## 동적 계획법


## 프로그래머스: 땅따먹기

[https://school.programmers.co.kr/learn/courses/30/lessons/12913](https://school.programmers.co.kr/learn/courses/30/lessons/12913)

4개의 열로 점수가 써진 땅이 있을 때, 1행부터 땅을 밟아서 숫자들을 모두 더했을 때 가장 큰 값을 찾는 문제다. 단, 다음행으로 내려갈 때 같은 열은 선택할 수 없다는 제약이 있다.

DP로 풀려면 초기값과 일반항을 알아야 하는데 아래와 같다.

- pseudo
```pseudo
# land N번째 각 열(인덱스) 점수 합계를 모은 배열을 a[N]이라 할 때,

초기값: a[0] = land[0]
일반항: a[N] = [
                  land[N][0] + max(a[N-1][1], a[N-1][2], a[N-1][3]),
                  land[N][1] + max(a[N-1][0], a[N-1][2], a[N-1][3]),
                  land[N][2] + max(a[N-1][0], a[N-1][1], a[N-1][3]),
                  land[N][3] + max(a[N-1][0], a[N-1][1], a[N-1][2]),
               ]  
```

코드 구현은 아래와 같다.

- javascript
```js
function solution(land) {
    let a = land[0]
    
    for (let x of land.slice(1)) {
        a = [
            x[0] + Math.max(a[1], a[2], a[3]),
            x[1] + Math.max(a[0], a[2], a[3]),
            x[2] + Math.max(a[0], a[1], a[3]),
            x[3] + Math.max(a[0], a[1], a[2]),
        ]
    }
    
    return Math.max(...a)
}
```

iterative DP 방식이다.

문제는 제일 마지막의 최대값만 리턴하도록 요구하므로, a 배열 누적을 굳이 쌓을필요는 없기에, for 문 안에서 계속 a 변수가 갱신되도록 했다.