{"name":"algorithm-dynamic-programming","ver":"[5100,dp,2402251615]","cat":"/algorithm","pathname":"/post/algorithm-dynamic-programming","title":"[Dynamic Programming] 동적 계획법","description":"동적 계획법의 이해와 알고리즘을 적용할 수 있는 경우","updated":"2024-02-25","content":"<h1 class=\"page-title\">[Dynamic Programming] 동적 계획법</h1><div class=\"page-meta\"><div class=\"page-description\">동적 계획법의 이해와 알고리즘을 적용할 수 있는 경우</div><div class=\"page-updated\">Last updated: 2024-02-25</div></div><div class=\"page-main\"><h2>동적 계획법</h2>\n<p>동적 계획법에 대한 이해를 위해 <a href=\"https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95\">나무위키</a> 등을 살펴봐도 무엇인지 알기 어렵다.</p>\n<p>개인적으로, 동적 계획법은 고등학교 수학시간 때 배웠던 <a href=\"https://namu.wiki/w/%EC%A0%90%ED%99%94%EC%8B%9D\">점화식</a>을 코드로 구현한 것이라고 보는 것이 이해하는데 더 빨랐다.</p>\n<p>점화식은 &quot;초기값&quot;과 &quot;일반항&quot;으로 나타낼 수 있다. 초기값부터 시작해서 순서대로 계산을 해나가면 답에 도달할 수 있다.</p>\n<h2>LeetCode - Climbing Stairs 문제</h2>\n<p><a href=\"https://leetcode.com/problems/climbing-stairs/\">70. Climbing Stairs</a> 문제는 n개의 계단을 오르는 가짓수를 구하는 문제다.</p>\n<p>계단을 1계단씩 또는 2계단씩 오를 수 있다고 할 때, 1계단만 있는 경우 (n = 1) 1계단 오르는 방법 1개만 존재하므로, 계단 오르는 가짓수는 1이다. 2계단이라면 (n = 2), 1계단씩 오르거나, 2계단을 한번에 오르는 방법 2개가 존재하므로, 계단 오르는 가짓수는 2이다.</p>\n<p>그렇다면 3계단은 어떨까? 1계단까지 오른다음 2계단을 한번에 오르는 방법과, 2계단까지 오른다음 마지막 1계단을 오르는 방법이 있다.</p>\n<p>4계단은 어떨까? 2계단까지 오른다음 2계단을 한번에 오르는 방법과, 3계단까지 오른다음 마지막 1계단을 오르는 방법이 있을 것이다.</p>\n<p>여기서 n개의 계단을 오르는 방법 찾는 법을 눈치챌 수 있으며, &quot;초기값&quot;과 &quot;일반항&quot;을 아래처럼 나타내고, 동적 계획법으로 풀 수 있다.</p>\n<ul>\n<li>pseudo</li>\n</ul>\n<pre><code class=\"language-pseudo\"><div class=\"codeline \"><span class=\"hljs-comment\"># n개 계단을 으로는 총 방법 가짓수가 f(n) 이라면...</div><div class=\"codeline \"> </div><div class=\"codeline \"></span>초기값<span class=\"hljs-leadline\">:</span> <span class=\"hljs-leadline\">f</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-leadline\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-leadline\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-leadline\">=</span> <span class=\"hljs-number\">2</span></div><div class=\"codeline \">일반항<span class=\"hljs-leadline\">:</span> <span class=\"hljs-leadline\">f</span>(<span class=\"hljs-leadline\">n</span>) <span class=\"hljs-leadline\">=</span> <span class=\"hljs-leadline\">f</span>(<span class=\"hljs-leadline\">n</span> <span class=\"hljs-leadline\">-</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-leadline\">+</span> <span class=\"hljs-leadline\">f</span>(<span class=\"hljs-leadline\">n</span> <span class=\"hljs-leadline\">-</span> <span class=\"hljs-number\">1</span>)</div></code></pre>\n<p>아래는 밑에서부터 위로 (Bottom-Up) 차곡차곡 답을 찾아가는 방법으로 푼 풀이다.</p>\n<ul>\n<li>python</li>\n</ul>\n<pre><code class=\"language-python\"><div class=\"codeline \"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:</div><div class=\"codeline \">    a = [<span class=\"hljs-literal\">None</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>] + [<span class=\"hljs-number\">0</span>]*(n-<span class=\"hljs-number\">2</span>)</div><div class=\"codeline \">    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>, n+<span class=\"hljs-number\">1</span>):</div><div class=\"codeline \">      a[i] = a[i-<span class=\"hljs-number\">2</span>] + a[i-<span class=\"hljs-number\">1</span>]</div><div class=\"codeline \">    </div><div class=\"codeline \">    <span class=\"hljs-keyword\">return</span> a[n]</div></code></pre>\n<p>a 리스트를 생성한 다음, 초기값은 1과 2로, 나머지는 0으로 초기화를 한다. 3번째부터 반복문으로 일반항을 풀어간다.</p>\n</div>"}
