{"name":"algorithm-binary-search","ver":"[0300,array,binarysearch,2402251436]","cat":"/algorithm","pathname":"/post/algorithm-binary-search","title":"[Array] 이진 탐색","description":"Array가 오름차순으로 정렬되어 있을 때, O(log n) 시간복잡도로 신속히 값을 검색하는 알고리즘","updated":"2024-02-24","content":"<article> <h1 class=\"page-title\">[Array] 이진 탐색</h1><div class=\"page-meta\"><div class=\"page-description\">Array가 오름차순으로 정렬되어 있을 때, O(log n) 시간복잡도로 신속히 값을 검색하는 알고리즘</div><div class=\"page-updated\">Last updated: 2024-02-24</div></div><div class=\"page-main\"><h2>이진 탐색</h2>\n<p>Array 안의 특정값 검색 알고리즘으로, <a href=\"https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89\">나무위키</a>에 있는 그림과 설명을 보면 어떤 원리인지 쉽게 이해가 된다. 사전에서 어떤 단어를 찾아보는 원리와 유사하다.</p>\n<p>반드시 <strong>Array 안의 요소들이 오름차순으로 정렬</strong>되어 있어야 알고리즘이 의미가 있다.</p>\n<h2>알고리즘 구현</h2>\n<p>원리는 간단한데, 실제로 구현하려면 다소 까다로울 수 있다. 아래와 같이 구현하면 된다.</p>\n<ul>\n<li>pseudo</li>\n</ul>\n<pre><code class=\"language-pseudo\"><div class=\"codeline \"><span class=\"hljs-comment\"># 탐색범위를 i 이상, j 미만으로 상정하고, 초기값으로 i 는 0, j 는 Array 길이를 대입</div><div class=\"codeline \"></span><span class=\"hljs-comment\"># 길이가 10인 Array 라면 아래와 같은 형태가 되며, 탐색범위 정의에 따라 전체 Array 를 탐색범위로 상정됨</div><div class=\"codeline \"> </div><div class=\"codeline \"></span><span class=\"hljs-leadline\">i</span>                                       <span class=\"hljs-leadline\">j</span>             </div><div class=\"codeline \"><span class=\"hljs-leadline\">|</span>                                       <span class=\"hljs-leadline\">|</span></div><div class=\"codeline \"><span class=\"hljs-leadline\">Ṿ</span>                                       <span class=\"hljs-leadline\">Ṿ</span></div><div class=\"codeline \"><span class=\"hljs-leadline\">a0,</span> <span class=\"hljs-leadline\">a1,</span> <span class=\"hljs-leadline\">a2,</span> <span class=\"hljs-leadline\">a3,</span> <span class=\"hljs-leadline\">a4,</span> <span class=\"hljs-leadline\">a5,</span> <span class=\"hljs-leadline\">a6,</span> <span class=\"hljs-leadline\">a7</span> <span class=\"hljs-leadline\">,a8,</span> <span class=\"hljs-leadline\">a9</span>      <span class=\"hljs-leadline\">&lt;--</span> 요소들은 오름차순</div><div class=\"codeline \"> </div><div class=\"codeline \"><span class=\"hljs-comment\"># 중간위치를 i + (j - i) / 2 로 계산 (결과의 정수값만 취함)</div><div class=\"codeline \"></span><span class=\"hljs-comment\"># Array[m] 값과 탐색값 t 를 비교</div><div class=\"codeline \"></span><span class=\"hljs-comment\"># Array[m] &lt; t 라면 m 위치 왼쪽값은 모두 버려도 되므로, i = m + 1</div><div class=\"codeline \"></span><span class=\"hljs-comment\"># 아니라면 m 위치 오른쪽값은 모두 버려도 되므로, j = m</div><div class=\"codeline \"></span><span class=\"hljs-comment\"># j &lt; i 인 경우, 다시 반복 계산...</span></div></code></pre>\n<p>왼쪽값을 버리는 것이 <code>i = m + 1</code>, 오른쪽값 버리는 것이 <code>j = m</code> 인 이유는, 탐색범위의 기준이 <code>i</code> 이상, <code>j</code> 미만이기 때문이다.</p>\n<p>그리고, <code>j &lt; i</code> 인 경우에 계속 반복적으로 위 알고리즘을 적용하면, 반드시 <code>i == j</code> 이 되는 때가 온다.</p>\n<p>이 때의 <code>i</code> 또는 <code>j</code> 가 찾고자 하는 탐색값이 위치한 곳이 되며, 만일 탐색값이 없다면 Array 안에 애초에 찾고자 하는 탐색값이 처음부터 없었다는 의미이다.</p>\n<h2>LeetCode - Search Insert Position 문제</h2>\n<p>LeetCode의 <a href=\"https://leetcode.com/problems/search-insert-position/description/\">35. Search Insert Position</a> 문제는 오름차순으로 이미 정렬이 되어 있는 <code>nums</code> Array가 주어졌을 때, 오름차순을 해치지 않으면서 어떤 특정값 <code>target</code>이 들어가야할 위치를 찾는 문제다.</p>\n<p>이진 탐색 코드 자체를 구현하는 것만으로도 풀 수 있다. <code>i == j</code> 지점이 바로 그 위치이기 때문이다.</p>\n<ul>\n<li>python</li>\n</ul>\n<pre><code class=\"language-python\"><div class=\"codeline \"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">searchInsert</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:</div><div class=\"codeline \">    i, j = <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums)</div><div class=\"codeline \"> </div><div class=\"codeline \">    <span class=\"hljs-keyword\">while</span> i &lt; j:</div><div class=\"codeline \">        m = i + (j - i) // <span class=\"hljs-number\">2</span></div><div class=\"codeline \">        (i := m + <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">if</span> nums[m] &lt; target <span class=\"hljs-keyword\">else</span> (j := m)</div><div class=\"codeline \">    </div><div class=\"codeline \">    <span class=\"hljs-keyword\">return</span> i</div></code></pre>\n<p>while 구문으로 <code>i &lt; j</code> 일 때만 순회한다.</p>\n<p>중간위치 <code>m</code> 을 계산하고, 중간위치에 있는 중간값 <code>nums[m]</code>과 <code>target</code>을 비교한 뒤, 언급한 바와 같이 탐색범위를 조정한다.</p>\n</div></article>"}
