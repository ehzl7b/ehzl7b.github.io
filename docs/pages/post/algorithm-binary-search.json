{"name":"algorithm-binary-search","ver":"[0300,array,binarysearch,2402241019]","cat":"/algorithm","pathname":"/post/algorithm-binary-search","title":"[Array] 이진 탐색","description":"Array가 오름차순으로 정렬되어 있을 때, O(log n) 시간복잡도로 신속히 값을 검색하는 알고리즘","updated":"2024-02-24","content":"<article> <h1 id=\"page-title\">[Array] 이진 탐색</h1><div id=\"page-meta\"><div id=\"page-description\">Array가 오름차순으로 정렬되어 있을 때, O(log n) 시간복잡도로 신속히 값을 검색하는 알고리즘</div><div id=\"page-updated\">Last updated: 2024-02-24</div></div><div id=\"page-main\"><h2>현재 작성중인 문서입니다.</h2>\n<h2>이진 탐색</h2>\n<p>Array 안의 특정값 검색 알고리즘으로, <a href=\"https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89\">나무위키</a>에 있는 그림과 설명을 보면 어떤 원리인지 쉽게 이해가 된다. 사전에서 어떤 단어를 찾아보는 원리와 유사하다.</p>\n<p>반드시 <strong>Array 안의 요소들이 오름차순으로 정렬</strong>이 되어 있어야 알고리즘이 의미가 있다.</p>\n<h2>알고리즘 구현</h2>\n<p>원리는 간단한데, 실제로 구현하려면 다소 까다로울 수 있다. 아래와 같이 구현하면 된다.</p>\n<ul>\n<li>pseudo</li>\n</ul>\n<pre><code class=\"language-pseudo\"><div class=\"codeline \"><span class=\"hljs-comment\">#</span></div></code></pre>\n<h2>LeetCode - Search Insert Position 문제</h2>\n<p>LeetCode의 <a href=\"https://leetcode.com/problems/search-insert-position/description/\">35. Search Insert Position</a> 문제는 이진 탐색 코드 자체를 구현해 보라는 문제로, 아래와 같이 풀 수 있다.</p>\n<ul>\n<li>rust</li>\n</ul>\n<pre><code class=\"language-rust\"><div class=\"codeline \"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">search_insert</span>(nums: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">i32</span>&gt;, target: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">i32</span> {</div><div class=\"codeline \">    <span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> i, <span class=\"hljs-keyword\">mut</span> j) = (<span class=\"hljs-number\">0</span>, nums.<span class=\"hljs-title function_ invoke__\">len</span>());</div><div class=\"codeline \">    </div><div class=\"codeline \">    <span class=\"hljs-keyword\">while</span> i &lt; j {</div><div class=\"codeline \">        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">m</span> = i + (j - i) / <span class=\"hljs-number\">2</span>;</div><div class=\"codeline \">        <span class=\"hljs-keyword\">match</span> nums[m] {</div><div class=\"codeline \">            x <span class=\"hljs-keyword\">if</span> x &lt; target =&gt; i = m + <span class=\"hljs-number\">1</span>,</div><div class=\"codeline \">            _ =&gt; j = m,</div><div class=\"codeline \">        }</div><div class=\"codeline \">    }</div><div class=\"codeline \">    </div><div class=\"codeline \">    i <span class=\"hljs-keyword\">as</span> _</div><div class=\"codeline \">}</div></code></pre>\n</div></article>"}
