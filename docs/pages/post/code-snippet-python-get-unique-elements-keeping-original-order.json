{"name":"code-snippet-python-get-unique-elements-keeping-original-order","ver":"[0030,2402071416]","cat":"/code-snippet","pathname":"/post/code-snippet-python-get-unique-elements-keeping-original-order","title":"Python 리스트에서 Index 순서를 유지하면서 중복없는 고유한 요소만 남기기","description":"리스트 각 요소를 체크하여 중복을 없애고 고유한 요소만 남기되, 기존 요소들의 인덱스 순서를 그대로 유지하는 방법","updated":"2021-09-07","content":"<article> <h1 id=\"page-title\">Python 리스트에서 Index 순서를 유지하면서 중복없는 고유한 요소만 남기기</h1><div id=\"page-meta\"><div id=\"page-description\">리스트 각 요소를 체크하여 중복을 없애고 고유한 요소만 남기되, 기존 요소들의 인덱스 순서를 그대로 유지하는 방법</div><div id=\"page-updated\">Last updated: 2021-09-07</div></div><div id=\"page-main\"><h2>중복 없애고 고유한 요소만 남기기</h2>\n<p>Python 에서, 어떤 리스트가 있을 때, 중복요소들을 모두 없애고 고유한 요소만 골라내거나 남기고 싶을 때, 리스트를 set 자료형으로 변환하였다가 다시 리스트로 환원하는 방법을 사용할 수 있다. 중복요소를 허용하지않는 set 자료형의 특성을 응용한 것이다.</p>\n<ul>\n<li>python</li>\n</ul>\n<pre><code class=\"language-python\"><div class=\"codeline \"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_unique_element</span>(<span class=\"hljs-params\">arr</span>):</div><div class=\"codeline \">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">set</span>(arr))</div></code></pre>\n<p>간편하지만 다소 문제가 있는데, <strong>리스트 요소들의 원래 인덱스 순서가 그대로 유지됨을 보장하지는 않는다</strong>는 것이다. <a href=\"https://docs.python.org/ko/3.9/library/stdtypes.html#set-types-set-frozenset\">Python 공식문서</a> 에서 set 자료형 부분을 살펴보면, &quot;집합은 원소의 위치나 삽입 순서를 기록하지 않습니다&quot; 라고 쓰여있다.</p>\n<h2>기존 인덱스 순서를 유지하면서, 고유한 요소만 남기기</h2>\n<p><a href=\"https://stackoverflow.com/questions/1960473/get-all-unique-values-in-a-javascript-array-remove-duplicates\">stackoverflow</a> 에서 방법을 찾아낼 수 있었다. Javascript 코드이지만 Python 으로도 충분히 구현할 수 있다.</p>\n<ul>\n<li>python</li>\n</ul>\n<pre><code class=\"language-python\"><div class=\"codeline \"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_unique_element</span>(<span class=\"hljs-params\">arr</span>):</div><div class=\"codeline \">    <span class=\"hljs-keyword\">return</span> [x <span class=\"hljs-keyword\">for</span> i, x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(arr) <span class=\"hljs-keyword\">if</span> arr.index(x) == i]</div></code></pre>\n<p>arr 리스트를 x 로 순회하면서, 요소 x 의 인덱스인 i 가 index 함수로 찾아낸 인덱스와 일치하는 경우만 골라낸다. 만일 일치하지 않는다면, 해당 x 요소값은 이미 어딘가 앞에서 한번 등장했었다라는 의미가 되므로 중복요소인 셈이다. 아래와 같이 이해할 수 있다.</p>\n<ul>\n<li>pseudo</li>\n</ul>\n<pre><code class=\"language-pseudo\"><div class=\"codeline \"><span class=\"hljs-leadline\">arr</span> <span class=\"hljs-leadline\">=</span> <span class=\"hljs-leadline\">[1,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">5</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">7</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">9</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">4</span><span class=\"hljs-leadline\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-leadline\">]</span></div><div class=\"codeline \">          <span class=\"hljs-leadline\">Ʌ</span>           <span class=\"hljs-leadline\">Ʌ</span></div><div class=\"codeline \">          <span class=\"hljs-leadline\">|</span>           <span class=\"hljs-leadline\">|</span></div><div class=\"codeline \">          <span class=\"hljs-leadline\">|</span>           <span class=\"hljs-comment\"># 이 요소를 순회할 때, x == 3, i == 5 이지만...</div><div class=\"codeline \"> </span>         <span class=\"hljs-leadline\">|</span>            </div><div class=\"codeline \">          <span class=\"hljs-comment\"># arr.index(3) == 1 이므로, arr.index(x) != i 가 된다.</span></div></code></pre>\n<p>참고로 이 인덱스 순서 유지 코드의 실행속도는 <strong>set 활용 코드보다 상당히 느리다.</strong></p>\n</div></article>"}
